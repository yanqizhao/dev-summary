#8.2RunLoop闲时上传日志、Git使用

[TOC]

##RunLoop
写在前面的，关于RunLoop的文章对我来说都比较深奥，没有全部看懂，只是暂时解决了我遇到的问题，下面三篇是我认为写的比较好的。

[ibireme-深入理解RunLoop](http://blog.ibireme.com/2015/05/18/runloop/)

[关于ibireme的笔记](http://finb.github.io/blog/2016/01/06/ios-runloop-xue-xi-and-yong-runloopshi-xian-dang-cheng-xu-kong-xian-shi-,zhi-xing-mou-xie-dai-ma/)

[利用RunLoop空闲时间执行预缓存任务](http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/)

说说我遇到的问题。

之前关于RunLoop的理解仅限于是一个运行循环，可以把任务丢给它让它在空闲的时间来处理，至于为什么要在空闲的时间，怎么处理一概不知。

最近新需求里要求把项目中之前上传的日志改在闲时上传，我完全没有想到是可以用RunLoop的，同事给我发了Sunny的文章后恍然大悟，虽然还不会用。

关于概念性的东西多看几遍是可以达到一知半解的，重要的思想，遇到问题的时候怎么能想到要用这样的方法。因为太懒，所以我的学习都是需求推动型，没有需求就没有动力。

因为要在闲时上传，我就必须知道什么时候是闲时，RunLoop是分为不同状态的：

```
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop
};
```

那么闲时就应该是处理完所有的任务即将休眠的时候，也就是`kCFRunLoopBeforeWaiting`这个状态，想想也是过分，刚打算睡觉就被人吵醒，还是反复不停的打扰/(ㄒoㄒ)/~~

那我怎么才能知道RunLoop进入这个状态了呢，监听呀，所以有个叫做`CFRunLoopObserverRef`的东东，用它来监听RunLoop的状态，进入你需要的状态时调用你写好的block代码块就好了。

很简单嘛，来一波代码！


```
// 获取当前线程RunLoop，除了主线程，其他线程的RunLoop默认都是懒加载的，需要用的时候get就好，不需要alloc、init
CFRunLoopRef runLoop = CFRunLoopGetCurrent(); 
// 我的需求是在默认的Mode下，而不是带有Common标记的，也就是ScrollView滚动时不上传
CFStringRef runLoopMode = kCFRunLoopDefaultMode;
CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler
(kCFAllocatorDefault, kCFRunLoopBeforeWaiting, true, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) {
    // TODO here
});
CFRunLoopAddObserver(runLoop, observer, runLoopMode);
```

到此，就算是完成了一丢丢。

```
// TODO在这里
dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);
dispatch_async(q, ^{
// 这里类似加一个锁
	if (!isRuning) {
		isRuning = YES;
                
		上传回调^(BOOL needToResend) {
			if (!needToResend) {
			CFRunLoopRemoveObserver(runLoop, observer, runLoopMode);
			_observer = nil;
			}
		isRuning = NO;
		}
	}
});
```

> 日志上传的流程应该是：
> 
> 程序开启时
> 
> ->添加观察者
> 
> ->存储需要上传的信息到本地数据库（无观察者时添加观察者）
> 
> ->RunLoop运行到BeforeWaiting状态
> 
> ->判断是否正在上传，NO，置为YES；YES，等待
> 
> ->从数据库取出需要上传的信息（无信息时传递无需重传，重置重试重试次数）
> 
> ->批量上传（成功后传递无需重传，重置重试次数，更新数据库已上传数据；失败后重试次数加1如未超过最大上传次数传递需要重传；超过最大上传次数传递无需重传，重置重试次数）
> 
> ->将正在上传置为NO
> 
> ->循环

## Git

[Git文档](https://git-scm.com/book/zh/v2)

[GitHub贡献代码的步骤](https://github.com/nixzhu/dev-blog/blob/master/2016-02-17-contribute-on-github.md)

[GitFlow备忘清单](http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html)

[Git Community Book](http://gitbook.liuhui998.com/index.html)






